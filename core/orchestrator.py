# Path: core/orchestrator.py
from typing import Dict, Any, List, Optional
import logging
import json
import re

class Orchestrator:
    """
    LUNA-ULTRA Orchestrator: Manages complex multi-agent tasks and coordinates execution.
    """
    def __init__(self, controller: Any):
        self.controller = controller
        self.agents = {}
        self.initialize_agents()

    def initialize_agents(self):
        """
        Dynamically imports and initializes agents based on configuration.
        """
        from agents.code_agent import CodeAgent
        from agents.automation_agent import AutomationAgent
        from agents.screen_agent import ScreenAgent
        from agents.system_agent import SystemAgent
        from agents.dynamic_agent import DynamicAgent
        from agents.architect_agent import ArchitectAgent

        # Register agents with their required dependencies
        self.agents["code"] = CodeAgent(self.controller.config, self.controller.llm_router)
        self.agents["automation"] = AutomationAgent(self.controller.config, self.controller.permission_engine)
        self.agents["screen"] = ScreenAgent(self.controller.config, self.controller.permission_engine)
        self.agents["system"] = SystemAgent(self.controller.config)
        self.agents["dynamic"] = DynamicAgent(self.controller.config, self.controller.llm_router, self.controller.permission_engine)
        self.agents["architect"] = ArchitectAgent(self.controller.config, self.controller.llm_router)
        
        logging.info(f"Orchestrator: Initialized {len(self.agents)} agents.")

    async def execute_plan(self, plan: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
        """
        Executes a multi-step plan generated by the LLM.
        """
        results = []
        for step in plan:
            agent_name = step.get("agent")
            action = step.get("action")
            params = step.get("params", {})
            
            logging.info(f"Orchestrator: Executing step - Agent: {agent_name}, Action: {action}")
            
            if agent_name in self.agents:
                try:
                    result = await self.agents[agent_name].execute(action, params)
                    results.append({"step": step, "result": result})
                    
                    # Stop if a critical step fails
                    if not result.get("success") and step.get("critical", True):
                        logging.error(f"Orchestrator: Critical failure in step {step}. Aborting plan.")
                        break
                except Exception as e:
                    logging.error(f"Orchestrator: Exception in agent {agent_name}: {str(e)}")
                    results.append({"step": step, "error": str(e)})
                    break
            else:
                logging.error(f"Orchestrator: Agent {agent_name} not found.")
                results.append({"step": step, "error": f"Agent {agent_name} not found"})
                break
                
        return results

    async def handle_task(self, user_input: str) -> Dict[str, Any]:
        """
        High-level task handler with Inner Monologue and Reasoning.
        """
        logging.info(f"Orchestrator: Handling task: {user_input}")

        # Step 1: Inner Monologue (Thinking Phase)
        thought_prompt = (
            f"User Task: \"{user_input}\"\n"
            f"Current Context: {self.controller.memory_manager.get_context(user_input, limit=3)}\n"
            f"Available Agents: {list(self.agents.keys())}\n"
            f"Think step-by-step. What is the best way to handle this? Should I use a tool or just chat?\n"
            f"If a new tool is needed, I can write one using the 'dynamic' agent.\n"
            f"Format your response as: THOUGHT: <your reasoning> | INTENT: <ACTION or CHAT>"
        )
        reasoning_response = await self.controller.llm_router.generate_response(thought_prompt)
        
        thought = "Thinking..."
        intent = "CHAT"
        if "THOUGHT:" in reasoning_response and "INTENT:" in reasoning_response:
            parts = reasoning_response.split("INTENT:")
            thought = parts[0].replace("THOUGHT:", "").strip()
            intent = parts[1].strip().upper()
        
        # Update GUI with the Thought Process
        if hasattr(self.controller, 'gui') and self.controller.gui:
            self.controller.gui.update_activity(f"ðŸ§  THOUGHT: {thought}")
            if self.controller.telegram.enabled:
                await self.controller.telegram.send_notification(f"ðŸ§  LUNA THOUGHT: {thought[:100]}...")

        # Step 2: Handle Chat Intent
        if "CHAT" in intent and "ACTION" not in intent:
            logging.info("Orchestrator: Handling as pure chat.")
            chat_response = await self.controller.llm_router.generate_response(user_input)
            return {"response": chat_response, "type": "chat", "thought": thought}

        # Step 3: Tool Planning (ACTION Intent)
        plan_prompt = (
            f"User Task: {user_input}\n"
            f"My Thought: {thought}\n"
            f"Available Agents: {list(self.agents.keys())}.\n"
            f"Generate a JSON list of steps with 'agent', 'action', and 'params'.\n"
            f"If I need to build a project, use 'architect'. If I need to run a script, use 'dynamic'.\n"
            f"If the task requires a new capability, use 'dynamic' to write the script first.\n"
            f"Example: [{{'agent': 'dynamic', 'action': 'generate_and_execute', 'params': {{'task_description': 'write a script to do X', 'available_tools': {{'python': True}}}}}}]"
        )
        plan_response_str = await self.controller.llm_router.generate_response(plan_prompt)
        
        plan = []
        try:
            json_match = re.search(r"\[.*\]", plan_response_str, re.DOTALL)
            if json_match:
                plan = json.loads(json_match.group(0))
        except json.JSONDecodeError as e:
            logging.error(f"Orchestrator: Plan parsing error: {str(e)}")

        # Step 4: Execute plan
        if plan:
            logging.info(f"Orchestrator: Executing plan with {len(plan)} steps.")
            self.controller.state_manager.update_task(user_input, plan)
            execution_results = []
            
            for step in plan:
                if hasattr(self.controller, 'gui') and self.controller.gui:
                    self.controller.gui.update_activity(f"âš™ï¸ EXECUTING: {step.get('agent')} -> {step.get('action')}")
                
                agent_name = step.get("agent")
                action = step.get("action")
                params = step.get("params", {})
                
                try:
                    result = await self.agents[agent_name].execute(action, params)
                    execution_results.append({"step": step, "result": result})
                    self.controller.state_manager.complete_step(result)
                    
                    if not result.get("success") and step.get("critical", True):
                        logging.error(f"Orchestrator: Critical failure in step {step}. Aborting.")
                        break
                except Exception as e:
                    logging.error(f"Orchestrator: Error in agent {agent_name}: {str(e)}")
                    break

            return {"plan": plan, "results": execution_results, "type": "tool_action", "thought": thought}
        else:
            logging.info("Orchestrator: No plan generated. Falling back to chat response.")
            chat_response = await self.controller.llm_router.generate_response(user_input)
            return {"response": chat_response, "type": "chat", "thought": thought}
