# Path: core/orchestrator.py
from typing import Dict, Any, List, Optional
import logging

class Orchestrator:
    """
    LUNA-ULTRA Orchestrator: Manages complex multi-agent tasks and coordinates execution.
    """
    def __init__(self, controller: Any):
        self.controller = controller
        self.agents = {}
        self.initialize_agents()

    def initialize_agents(self):
        """
        Dynamically imports and initializes agents based on configuration.
        """
        from agents.code_agent import CodeAgent
        from agents.automation_agent import AutomationAgent
        from agents.screen_agent import ScreenAgent
        from agents.system_agent import SystemAgent

        # Register agents with their required dependencies
        self.agents['code'] = CodeAgent(self.controller.config, self.controller.llm_router)
        self.agents['automation'] = AutomationAgent(self.controller.config, self.controller.permission_engine)
        self.agents['screen'] = ScreenAgent(self.controller.config, self.controller.permission_engine)
        self.agents['system'] = SystemAgent(self.controller.config)
        
        logging.info(f"Orchestrator: Initialized {len(self.agents)} agents.")

    async def execute_plan(self, plan: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
        """
        Executes a multi-step plan generated by the LLM.
        """
        results = []
        for step in plan:
            agent_name = step.get('agent')
            action = step.get('action')
            params = step.get('params', {})
            
            logging.info(f"Orchestrator: Executing step - Agent: {agent_name}, Action: {action}")
            
            if agent_name in self.agents:
                try:
                    result = await self.agents[agent_name].execute(action, params)
                    results.append({"step": step, "result": result})
                    
                    # Stop if a critical step fails
                    if not result.get("success") and step.get("critical", True):
                        logging.error(f"Orchestrator: Critical failure in step {step}. Aborting plan.")
                        break
                except Exception as e:
                    logging.error(f"Orchestrator: Exception in agent {agent_name}: {str(e)}")
                    results.append({"step": step, "error": str(e)})
                    break
            else:
                logging.error(f"Orchestrator: Agent {agent_name} not found.")
                results.append({"step": step, "error": f"Agent {agent_name} not found"})
                break
                
        return results

    async def handle_task(self, task_description: str) -> Dict[str, Any]:
        """
        High-level task handler: Plan -> Execute -> Report.
        """
        # 1. Generate plan using LLM
        plan_prompt = f"User Task: {task_description}\nAvailable Agents: {list(self.agents.keys())}\nGenerate a JSON list of steps with 'agent', 'action', and 'params'."
        plan_response = await self.controller.llm_router.generate_response(plan_prompt)
        
        # 2. Parse plan (simplified for demo)
        import json
        try:
            # Extract JSON from response
            import re
            json_match = re.search(r"\[.*\]", plan_response, re.DOTALL)
            if json_match:
                plan = json.loads(json_match.group(0))
            else:
                return {"error": "Failed to generate a valid execution plan."}
        except Exception as e:
            return {"error": f"Plan parsing error: {str(e)}"}

        # 3. Execute plan
        execution_results = await self.execute_plan(plan)
        return {"plan": plan, "results": execution_results}
